{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","models/Difficulty.ts","solver/MatrixEntry.ts","solver/LinkedMatrix.ts","solver/SudokuSolver.ts","models/Generator.ts","workers/GeneratePuzzle.worker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_slicedToArray","arr","Array","isArray","_arrayWithHoles","_arr","_n","_d","_e","undefined","_s","_i","iterator","next","done","push","length","err","_iterableToArrayLimit","TypeError","_nonIterableRest","_toConsumableArray","arr2","_arrayWithoutHoles","iter","toString","from","_iterableToArray","_nonIterableSpread","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","configurable","writable","_createClass","protoProps","staticProps","DIFFICULTY","MatrixEntry","x","y","this","size","left","right","up","down","entry","LinkedSparseMatrix","data","root","columnHeaders","sparseRepresentation","convertDenseMatrixToSparseRepresentation","generateRows","columnHeader","indexOf","map","row","reduce","sparse","index","horizontalExclude","Down","Right","verticalExclude","X","decrementSize","horizontalInclude","Up","Left","verticalInclude","incrementSize","_this","forEach","dataRow","temporaryRowRoot","dataPoint","appendColumnHeaders","currentColumnHeader","verticalInsert","horizontalInsert","count","SudokuSolver","rowMetaData","sudokuRuleMatrix","generateMatrixRows","generateSudokuRuleMatrix","sudoku","sudokuRuleMatrixWithGivenNumbers","applyGivenNumbersToRules","linkedmatrix","solutions","recurse","filter","metadata","cellValue","column","currentAttempt","Root","sort","bestColumn","findBestColumnToStartAt","Size","bestColumnIndex","getColumnIndexOf","cover","Y","uncover","pop","_this2","cellConstraints","getCellContraints","rowContraints","getRowContraints","columnContraints","getColumnConstraints","blockConstraints","getBlockConstraints","concat","result","cell","block","Math","floor","BASE","Generator","difficulty","solution","shuffle","solver","startAt","Date","now","removed","allowedAttempts","random","includes","solve","ellapsedTime","console","log","base","moveRowOrColumn","_this$getFromAndTo2","getFromAndTo","to","round","moveColumn","moveRow","arguments","temp","ctx","self","addEventListener","message","puzzleData","tries","generator","generate","getPuzzleData","Error","runGenerator","postMessage","__webpack_exports__"],"mappings":"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","file":"b96a843152969089af28.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/sudoku/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export enum DIFFICULTY {\r\n  VeryEasy = 30,\r\n  Easy = 36,\r\n  Normal = 42,\r\n  Hard = 50,\r\n  VeryHard = 57\r\n}\r\n","export default class MatrixEntry {\r\n  private size: number;\r\n  private left: MatrixEntry;\r\n  private right: MatrixEntry;\r\n  private up: MatrixEntry;\r\n  private down: MatrixEntry;\r\n\r\n  constructor(private x: number, private y: number) {\r\n    this.size = 0;\r\n\r\n    this.left = this;\r\n    this.right = this;\r\n    this.up = this;\r\n    this.down = this;\r\n  }\r\n\r\n  public get X(): number {\r\n    return this.x;\r\n  }\r\n\r\n  public get Y(): number {\r\n    return this.y;\r\n  }\r\n\r\n  public get Left(): MatrixEntry {\r\n    return this.left;\r\n  }\r\n\r\n  public get Right(): MatrixEntry {\r\n    return this.right;\r\n  }\r\n\r\n  public get Up(): MatrixEntry {\r\n    return this.up;\r\n  }\r\n\r\n  public get Down(): MatrixEntry {\r\n    return this.down;\r\n  }\r\n\r\n  public get Size(): number {\r\n    return this.size;\r\n  }\r\n\r\n  public incrementSize(): void {\r\n    ++this.size;\r\n  }\r\n\r\n  public decrementSize(): void {\r\n    --this.size;\r\n  }\r\n\r\n  public horizontalExclude(): void {\r\n    this.left.right = this.right;\r\n    this.right.left = this.left;\r\n  }\r\n\r\n  public verticalExclude(): void {\r\n    this.up.down = this.down;\r\n    this.down.up = this.up;\r\n  }\r\n\r\n  public horizontalInclude(): void {\r\n    this.left.right = this;\r\n    this.right.left = this;\r\n  }\r\n\r\n  public verticalInclude(): void {\r\n    this.up.down = this;\r\n    this.down.up = this;\r\n  }\r\n\r\n  public horizontalInsert(entry: MatrixEntry): void {\r\n    entry.left = this.left;\r\n    entry.right = this;\r\n\r\n    this.left.right = entry;\r\n    this.left = entry;\r\n  }\r\n\r\n  public verticalInsert(entry: MatrixEntry): void {\r\n    entry.up = this.up;\r\n    entry.down = this;\r\n\r\n    this.up.down = entry;\r\n    this.up = entry;\r\n  }\r\n}\r\n","import MatrixEntry from './MatrixEntry';\r\n\r\n/**\r\n * A sparse matrix where each element is douply linked in both the row and column direction.\r\n */\r\nexport default class LinkedSparseMatrix {\r\n  private root: MatrixEntry;\r\n  private columnHeaders: MatrixEntry[];\r\n\r\n  constructor(data: boolean[][]) {\r\n    this.root = new MatrixEntry(-1, -1);\r\n    this.columnHeaders = [];\r\n    const sparseRepresentation = this.convertDenseMatrixToSparseRepresentation(data);\r\n    this.generateRows(sparseRepresentation);\r\n  }\r\n\r\n  public getColumnIndexOf(columnHeader: MatrixEntry): number {\r\n    return this.columnHeaders.indexOf(columnHeader);\r\n  }\r\n\r\n  public get Root(): MatrixEntry {\r\n    return this.root;\r\n  }\r\n\r\n  /**\r\n   * Converts matrix of ones and zeroes where most elements are\r\n   * zeroes, i.e. a sparse matrix to a representation where each element\r\n   * correponds to the index of a one. This greatly reduces the ammount\r\n   * of elements we are required to keep track of.\r\n   */\r\n  private convertDenseMatrixToSparseRepresentation(data: boolean[][]): number[][] {\r\n    return data.map(\r\n      row =>\r\n        row.reduce(\r\n          (sparse, value, index) => {\r\n            if (value) {\r\n              sparse.push(index);\r\n            }\r\n            return sparse;\r\n          },\r\n          [] as number[]\r\n        ),\r\n      [] as number[][]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * All rows that have an entry at the provided column index are excluded from the linked matrix.\r\n   * They are not removed from the columns array so that they can be added gain.\r\n   * This is made possible by the way the data in structured. An entry is linked to a column\r\n   * header only if it has an entry in the corresponding column. By itterating through\r\n   * the Down link all rows can be found. All entries in the entrire row can then\r\n   * be found and excluded through the Right link.\r\n   */\r\n  public cover(index: number): void {\r\n    const columnHeader = this.columnHeaders[index];\r\n\r\n    columnHeader.horizontalExclude();\r\n    for (let row = columnHeader.Down; row !== columnHeader; row = row.Down) {\r\n      for (let entry = row.Right; entry !== row; entry = entry.Right) {\r\n        entry.verticalExclude();\r\n        this.columnHeaders[entry.X].decrementSize();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * All rows that have an entry at the provided column index are included in the linked matrix.\r\n   * The same approach is taken as in the cover method but the Up and Left are used instead.\r\n   * That way the original order is maintained.\r\n   */\r\n  public uncover(index: number): void {\r\n    const columnHeader = this.columnHeaders[index];\r\n\r\n    columnHeader.horizontalInclude();\r\n    for (let row = columnHeader.Up; row !== columnHeader; row = row.Up) {\r\n      for (let entry = row.Left; entry !== row; entry = entry.Left) {\r\n        entry.verticalInclude();\r\n        this.columnHeaders[entry.X].incrementSize();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates each row of the data. Each row is built on temporary entry that is later removed.\r\n   * Each element in each row is also linked to a column. This methods makes sure that\r\n   * all required column headers exist. By linking the entries in both the row and column\r\n   * direction the time it takes to traverse the matrix to find ones is greatly reduced.\r\n   */\r\n  private generateRows(sparseRepresentation: number[][]) {\r\n    sparseRepresentation.forEach((dataRow, i) => {\r\n      const temporaryRowRoot = new MatrixEntry(-1, i);\r\n      dataRow.forEach(dataPoint => {\r\n        const entry = new MatrixEntry(dataPoint, i);\r\n\r\n        if (this.columnHeaders.length <= dataPoint) {\r\n          this.appendColumnHeaders(dataPoint - this.columnHeaders.length + 1);\r\n        }\r\n        const currentColumnHeader = this.columnHeaders[dataPoint];\r\n        currentColumnHeader.verticalInsert(entry);\r\n        currentColumnHeader.incrementSize();\r\n        temporaryRowRoot.horizontalInsert(entry);\r\n      });\r\n      temporaryRowRoot.horizontalExclude();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Appends new MatrixEntries called headers (they are not part of the data).\r\n   * These linked to the root element, each element in a row is also part of a linked list that\r\n   * is based of a column header.\r\n   */\r\n  private appendColumnHeaders(count: number): void {\r\n    while (count--) {\r\n      const columnHeader = new MatrixEntry(this.columnHeaders.length, -1);\r\n      this.root.horizontalInsert(columnHeader);\r\n      this.columnHeaders.push(columnHeader);\r\n    }\r\n  }\r\n}\r\n","import LinkedSparseMatrix from './LinkedMatrix';\r\nimport MatrixEntry from './MatrixEntry';\r\n\r\ntype metadata = {\r\n  row: number;\r\n  column: number;\r\n  block: number;\r\n  value: number;\r\n};\r\n\r\n/**\r\n * A solver that uses DLX to solve puzzles. It is expensive to initialize.\r\n * However it is stateless so once it has been initialized it can be be used to solve many puzzles.\r\n */\r\nexport default class SudokuSolver {\r\n  private rowMetaData: metadata[];\r\n  private sudokuRuleMatrix: boolean[][];\r\n\r\n  constructor() {\r\n    this.rowMetaData = this.generateMatrixRows();\r\n    this.sudokuRuleMatrix = this.generateSudokuRuleMatrix();\r\n  }\r\n\r\n  /**\r\n   * Solves a sudoku by initializing the the recursive link dancing.\r\n   * Returns an array containing the rows that solve the array. It is fairly useless unless\r\n   * it is mapped to actual values.\r\n   */\r\n  public solve(sudoku: (number | null)[][]): number[][] {\r\n    const sudokuRuleMatrixWithGivenNumbers = this.applyGivenNumbersToRules(sudoku);\r\n    const linkedmatrix = new LinkedSparseMatrix(sudokuRuleMatrixWithGivenNumbers);\r\n    const solutions = [] as number[][];\r\n    const stack = [] as number[];\r\n\r\n    this.recurse(linkedmatrix, solutions, stack);\r\n\r\n    return solutions;\r\n  }\r\n\r\n  /**\r\n   * Since a puzzle has clues, the entire matrix is not used.\r\n   * Only the rows that represent empty cells and given cells\r\n   * are included in the matrix that is represents the exact cover problem.\r\n   */\r\n  private applyGivenNumbersToRules(sudoku: (number | null)[][]): boolean[][] {\r\n    return this.sudokuRuleMatrix.filter((r, i) => {\r\n      const metadata = this.rowMetaData[i];\r\n      const cellValue = sudoku[metadata.row][metadata.column];\r\n      return cellValue === null || cellValue === metadata.value;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Implements the DLX algorithm, explained further here: https://arxiv.org/abs/cs/0011047\r\n   * In order to keep it stateless an array is passed around that includes all the found solutions.\r\n   * The current attempt is also passed around.\r\n   */\r\n  private recurse(\r\n    linkedmatrix: LinkedSparseMatrix,\r\n    solutions: number[][],\r\n    currentAttempt: number[]\r\n  ): void {\r\n    const succeeded = linkedmatrix.Root.Right === linkedmatrix.Root;\r\n    if (succeeded) {\r\n      solutions.push([...currentAttempt].sort());\r\n      return;\r\n    }\r\n\r\n    const bestColumn = this.findBestColumnToStartAt(linkedmatrix.Root);\r\n    const failed = bestColumn.Size < 1;\r\n    if (failed) {\r\n      return;\r\n    }\r\n\r\n    const bestColumnIndex = linkedmatrix.getColumnIndexOf(bestColumn);\r\n    linkedmatrix.cover(bestColumnIndex);\r\n    for (let row = bestColumn.Down; row !== bestColumn; row = row.Down) {\r\n      currentAttempt.push(row.Y);\r\n      for (let entry = row.Right; entry !== row; entry = entry.Right) {\r\n        linkedmatrix.cover(entry.X);\r\n      }\r\n      this.recurse(linkedmatrix, solutions, currentAttempt);\r\n      for (let entry = row.Left; entry !== row; entry = entry.Left) {\r\n        linkedmatrix.uncover(entry.X);\r\n      }\r\n      currentAttempt.pop();\r\n    }\r\n    linkedmatrix.uncover(bestColumnIndex);\r\n  }\r\n\r\n  /**\r\n   * The column used to start each itteration in the algorithm can be select anyway\r\n   * that I see fit. Knuth suggest selecting the column with the fewest entried so\r\n   * that is what I do here.\r\n   */\r\n  private findBestColumnToStartAt(root: MatrixEntry): MatrixEntry {\r\n    let bestColumn = root.Right;\r\n    for (let column = bestColumn.Right; column !== root; column = column.Right) {\r\n      if (column.Size < bestColumn.Size) {\r\n        bestColumn = column;\r\n      }\r\n    }\r\n    return bestColumn;\r\n  }\r\n\r\n  /**\r\n   * Generates a matrix based on the row metadata created earlier.\r\n   * The columns are crated from the restrictions that apply to a puzzle.\r\n   * 1) A cell can only contain a single value, represented by cellConstraints\r\n   * 2) A row can only contain a specific value once, represented by rowConstraints\r\n   * 3) A column can only contain a specific value, represented by columnConstraints\r\n   * 4) A block can only contain a specific value, represented by blockConstraints\r\n   */\r\n  private generateSudokuRuleMatrix(): boolean[][] {\r\n    return this.rowMetaData.map(entry => {\r\n      const cellConstraints = this.getCellContraints(entry);\r\n      const rowContraints = this.getRowContraints(entry);\r\n      const columnContraints = this.getColumnConstraints(entry);\r\n      const blockConstraints = this.getBlockConstraints(entry);\r\n      return [...cellConstraints, ...rowContraints, ...columnContraints, ...blockConstraints];\r\n    });\r\n  }\r\n  private getCellContraints(entry: metadata): boolean[] {\r\n    const result = [] as boolean[];\r\n    const cell = entry.row * 9 + entry.column;\r\n    for (let i = 0; i < 81; i++) {\r\n      result.push(i === cell);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private getRowContraints(entry: metadata): boolean[] {\r\n    const result = [] as boolean[];\r\n    for (let row = 0; row < 9; row++) {\r\n      for (let value = 1; value <= 9; value++) {\r\n        result.push(entry.value === value && entry.row === row);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private getColumnConstraints(entry: metadata): boolean[] {\r\n    const result = [] as boolean[];\r\n    for (let column = 0; column < 9; column++) {\r\n      for (let value = 1; value <= 9; value++) {\r\n        result.push(entry.value === value && entry.column === column);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private getBlockConstraints(entry: metadata): boolean[] {\r\n    const result = [] as boolean[];\r\n    for (let block = 0; block < 9; block++) {\r\n      for (let value = 1; value <= 9; value++) {\r\n        result.push(entry.value === value && entry.block === block);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Generates the rows that are used to create the matrix that is used to find\r\n   * an exact cover.The row metadata contains the row, columns, block and value\r\n   * of the cell in the sudoku. An entry represent the sudoku row column and\r\n   * value in all permutaions.\r\n   */\r\n  private generateMatrixRows(): metadata[] {\r\n    const result = [] as metadata[];\r\n    for (let row = 0; row < 9; row++) {\r\n      for (let column = 0; column < 9; column++) {\r\n        for (let value = 1; value <= 9; value++) {\r\n          const block = Math.floor(row / 3) * 3 + Math.floor(column / 3);\r\n          result.push({\r\n            row,\r\n            column,\r\n            block,\r\n            value\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n","import { DIFFICULTY } from './Difficulty';\r\nimport SudokuSolver from '../solver/SudokuSolver';\r\n\r\nconst BASE = [\r\n  [3, 6, 1, 7, 2, 5, 9, 4, 8],\r\n  [5, 8, 7, 9, 6, 4, 2, 1, 3],\r\n  [4, 9, 2, 8, 3, 1, 6, 5, 7],\r\n  [6, 3, 8, 2, 5, 9, 4, 7, 1],\r\n  [1, 7, 4, 6, 8, 3, 5, 9, 2],\r\n  [2, 5, 9, 1, 4, 7, 8, 3, 6],\r\n  [7, 4, 6, 3, 9, 2, 1, 8, 5],\r\n  [9, 2, 3, 5, 1, 8, 7, 6, 4],\r\n  [8, 1, 5, 4, 7, 6, 3, 2, 9]\r\n];\r\n\r\nexport default class Generator {\r\n  private solution: number[][];\r\n  private data: (null | number)[][];\r\n\r\n  constructor(private difficulty: DIFFICULTY) {\r\n    this.solution = this.shuffle(BASE);\r\n    this.data = [];\r\n  }\r\n\r\n  public generate() {\r\n    const solver = new SudokuSolver();\r\n    const startAt = Date.now();\r\n    this.data = this.solution.map(r => [...r]);\r\n    const removed = [] as string[];\r\n    let allowedAttempts = 1273;\r\n    while (removed.length < this.difficulty && allowedAttempts--) {\r\n      let row;\r\n      let column;\r\n      do {\r\n        row = ~~(Math.random() * 9);\r\n        column = ~~(Math.random() * 9);\r\n      } while (removed.includes(`${row}:${column}`));\r\n      let value = this.data[row][column];\r\n      this.data[row][column] = null;\r\n      const solutions = solver.solve(this.data);\r\n      if (solutions.length === 1) {\r\n        removed.push(`${row}:${column}`);\r\n      } else {\r\n        this.data[row][column] = value;\r\n      }\r\n    }\r\n    const ellapsedTime = Date.now() - startAt;\r\n\r\n    if (allowedAttempts > 0) {\r\n      console.log(`It took ${ellapsedTime}ms to generate a ${DIFFICULTY[this.difficulty]} puzzle`);\r\n      return true;\r\n    } else {\r\n      console.log(\r\n        `Failed to generate a ${DIFFICULTY[this.difficulty]} puzzle after ${ellapsedTime}ms`\r\n      );\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private shuffle(base: number[][]): number[][] {\r\n    const data = BASE.map(r => [...r]);\r\n    for (let i = 0; i < 4200; i++) {\r\n      this.moveRowOrColumn(data);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  public getPuzzleData(): ([number, boolean])[][] {\r\n    return this.data.map((r, i) =>\r\n      r.map(\r\n        (y, l) =>\r\n          [this.solution[i][l], this.solution[i][l] === this.data[i][l]] as [number, boolean]\r\n      )\r\n    );\r\n  }\r\n\r\n  private moveRowOrColumn(data: number[][]) {\r\n    const [from, to] = this.getFromAndTo();\r\n    if (!!Math.round(Math.random())) {\r\n      this.moveColumn(data, from, to);\r\n    } else {\r\n      this.moveRow(data, from, to);\r\n    }\r\n  }\r\n\r\n  private getFromAndTo(from: number = -1): [number, number] {\r\n    from = from === -1 ? Math.floor(Math.random() * 3) : from;\r\n    let to = ~~(Math.random() * 3);\r\n    if (to === from) {\r\n      return this.getFromAndTo(from);\r\n    }\r\n    const block = ~~(Math.random() * 3);\r\n    return [block * 3 + from, block * 3 + to];\r\n  }\r\n\r\n  private moveRow(data: number[][], from: number, to: number) {\r\n    const temp = data[to];\r\n    data[to] = data[from];\r\n    data[from] = temp;\r\n  }\r\n\r\n  private moveColumn(data: number[][], from: number, to: number) {\r\n    data.forEach(row => {\r\n      const temp = row[to];\r\n      row[to] = row[from];\r\n      row[from] = temp;\r\n    });\r\n  }\r\n}\r\n","import Generator from '../models/Generator';\r\nimport { DIFFICULTY } from '../models/Difficulty';\r\n\r\nconst ctx: Worker = self as any;\r\n\r\nctx.addEventListener('message', message => {\r\n  const difficulty = message.data as DIFFICULTY;\r\n  const puzzleData = runGenerator(difficulty);\r\n  ctx.postMessage({\r\n    puzzleData,\r\n    difficulty\r\n  });\r\n});\r\n\r\nfunction runGenerator(difficulty: DIFFICULTY): [number, boolean][][] {\r\n  let tries = 10;\r\n  do {\r\n    const generator = new Generator(difficulty);\r\n    if (generator.generate()) {\r\n      return generator.getPuzzleData();\r\n    }\r\n  } while (--tries);\r\n  throw new Error('Could not generate puzzle.');\r\n}\r\n\r\nexport default null as any;\r\n"],"sourceRoot":""}